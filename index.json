[{"content":" Hello OS!\nThinking 0.1 Git 的使用 1 # 操作流程 # # init mkdir ~/learnGit \u0026amp;\u0026amp; cd ~/learnGit git init . # 1 touch README.txt git status \u0026gt; Untracked.txt # 2 echo \u0026#34;hello world!\u0026#34; \u0026gt; README.txt git add . git status \u0026gt; Staged.txt # 3 git commit -m \u0026#34;23371263\u0026#34; cat Untracked.txt cat Stage.txt # 4 echo \u0026#34;hello git!\u0026#34; \u0026gt; README.txt git status \u0026gt; Modified.txt cat Modified.txt 流程分析 # Git 将文件分为四种状态：untracked，unmodified，modified，staged。#1 的文件处于 untracked 的状态。#2 的文件在 add 之后变成了 staged 的状态，并在 #3 commit 之后变成了 unmodified 的状态。#4 的文件在修改之后，变成了 modified 的状态。\n这是一种有限状态机的设计，用图示可以表示为如下：\nstateDiagram [*] --\u003e untracked untracked --\u003e staged : git add file staged --\u003e unmodified : git commit unmodified --\u003e modified : edit file modified --\u003e staged : git add file staged --\u003e modified : edit modified --\u003e unmodified : git checkout -- file staged --\u003e untracked : git rm --cached file modified --\u003e untracked : git rm file VS Code 的自动暂存 # 平时我们在使用 VS Code 的时候，在一个 Git 仓库中，VS Code 会自动把新建的文件（包括修改的内容）提交到暂存区，自动变成 staged 状态。我们输入提交消息并 commit 之后，文件就变成了 unmodified 的状态。也就是说，VS Code 将这四种状态化简为了两种状态，而自动帮我们处理了其他两种状态与这两种状态之间的转换：\nstateDiagram [*] --\u003e staged staged --\u003e unmodified : commit unmodified --\u003e staged : edit 我觉得这非常方便，从多种状态转换的路径中抽离出最常用的两条路径供用户手动处理，而自动处理其他部分的内容，是一种非常自然的设计。\nIDEA 的文件状态转换 # 反观 IntelliJ IDEA，没有像 VS Code 这样流畅的设计，它的文件状态的转换逻辑和 Git 的设计相同，没有进行简化。所以我们在 IDEA 里新建一个文件，默认是 untracked 状态的。需要在版本管理页面手动为文件打勾，表示将其暂存，才能提交这些文件。多一种操作当然多一些自由度，但是也增加了操作的复杂性。\n这样的文件状态转换的方式，与 .gitignore 文件相结合时，也会遇到一些问题。.gitignore 忽略的是 untracked 状态的文件。如果你打开了 IDEA 的自动暂存功能，它就真的把新建的文件提交到暂存区，然后不管不顾了——也就是说，如果你在将某一文件（或者文件类型）加入.gitignore 之前就创建了这一文件（或者这一类型的文件），那么这个文件仍然会被 Git 追踪。VS Code 对待的方式则不同——如果你在创建之后把文件加入了 .gitignore，那么即使它被暂存了，它依然会被 VS Code 认为是需要忽略的文件，于是它会被清出暂存区，并设置成被忽略的状态。只有被提交过的文件，VS Code 才不会去将它忽略。\n总的来说，虽然 IDEA 的逻辑设计与 Git 如出一辙，但我并不认为这是一个好的设计——也许对于 Git 这样的命令行工具来说这种完备性是需要的，但作为一个现代的、智能的 IDE，VS Code（姑且认为它是个 IDE）这种更简洁的方式更加符合直觉。\nThinking 0.2 箭头与命令 # \u0026ldquo;add the file\u0026rdquo;: git add \u0026ldquo;stage the file\u0026rdquo;: git add \u0026ldquo;commit\u0026rdquo;: git commit git add 命令对应的操作是两种：一种是将 untracked 的文件放入暂存区，一种是将 modified 的文件放入暂存区。其实本质上，都是将文件的变化放入暂存区中以记录。\nThinking 0.3 Git 的一些场景 # Git 如何恢复文件 # 以往我的理解是从 Git 的三个区域入手的，但现在我发现也许从文件的四个状态去理解恢复机制会更好。 untracked 的文件被误删，因为它和 Git 还没产生关系，就没法通过 Git 恢复了。 unmodified 的文件被误删，此时它的状态就变成了 modified。我们可以通过 git restore \u0026lt;file\u0026gt; 来将其恢复到 unmodified 的状态。 modified 的文件被误删，状态还是 modified。我们可以把删除也理解为一种修改，而这次的修改（即删除）与上次的修改合并了。所以无论如何，我们也只能通过 git restore \u0026lt;file\u0026gt; 把它恢复到 unmodified 的状态。 另一种理解是，我们上一次的修改尚未被 Git 记录，所以没法通过 Git 恢复上一次修改的部分。 staged 的文件被误删。此时文件的状态变为 modified。此时我们也可以通过 git restore \u0026lt;file\u0026gt; 的方法将其恢复到 staged 的状态。 注意这里是恢复到 staged 状态而不是更早的 unmodified 的状态。如果我们想要（将一个 staged 状态下的文件）恢复到更早的 unmodified 的状态，我们首先需要通过 git restore --staged \u0026lt;file\u0026gt; 来将 staged 状态的文件恢复到 modified 的状态，再通过 git restore \u0026lt;file\u0026gt; 来把它恢复到先前的 unmodified 的状态。 如果 staged 的文件被误删，此时又 git commit 提交了暂存区。已经 staged 的“文件”变成了 unmodified 的状态，但由于删除的操作并未暂存，所以该文件仍处于 modified 的状态。我们还是可以通过 git restore \u0026lt;file\u0026gt; 来把它恢复到 unmodified 的状态。 可以看到，git restore \u0026lt;file\u0026gt; 可以将一个处于 modified 的状态的文件恢复到其上一个状态（unmodified 或者 staged），而 git restore --staged \u0026lt;file\u0026gt; 可以将一个处于 staged 的状态的文件恢复到其上一个状态（modified 或者 untracked）。所谓的误删操作，在 Git 看来就是将文件从其当前状态变为了 modified 状态而已。 如果我们删除了一个文件，并已经通过 git commit 提交了（这还能算是误删吗？），我们也可以恢复其历史版本（如果删除之前我们提交过的话）。可以使用 git log 查看提交的历史记录，确定某一提交有我们所需的文件后，记住其哈希值的前几位，使用 git restore --source=\u0026lt;hashcode\u0026gt; \u0026lt;file\u0026gt; 来恢复该文件。恢复后，该文件会处于 modified 的状态。 事实上在 Git 中我们很难彻底删除一个文件，即便是我们毁灭了某几条提交记录，兴许还有办法把这几条记录给找回。这种高级操作大概也叫 Git 魔法（\n从 Git 的三个区域入手大概也能理清楚 git restore 的逻辑，但我想应该比上面这种方法要复杂。\nGit 如何删除文件 # 这个问题从 Git 的三个区域分别讲更好。Git 复杂的原因之一就是有很多个角度去看待它的操作，而且不同操作的最佳视角还不一样。\n从工作区删除一个文件。直接使用系统的 rm 就好。 从暂存区删除一个文件。我们可以使用 git rm \u0026lt;file\u0026gt; 命令。这个命令就是 Git 版 rm，它会同时将工作区和暂存区的这个文件全部删除——前提是这两份版本相同。也就是说，如果你暂存了这个文件之后又修改了它，使用这个命令时 Git 就会发出警告并终止操作。要想强制执行，加 -f 即可。 如果想保留工作区的文件，而删除暂存区的文件，可以使用 git rm --cached \u0026lt;file\u0026gt;。也就是说，git add \u0026lt;file\u0026gt; 的反义词其实是 git rm --cached \u0026lt;file\u0026gt; ——非常糟糕，对吧？ 如果真要这么说，git rm --cached \u0026lt;file\u0026gt; 和 git restore --staged \u0026lt;file\u0026gt; 是同义词。更糟糕了。 从版本库删除一个文件。这件事情就难办了， 但是使用 Git 的新手又经常遇到这样的问题——经常不检查即将 commit 的代码，而把自己的个人信息或者隐私给提交了。我之前就遇到过这样的问题。下面是我的解决方法，当然可能清除得不彻底。 使用 pip 安装 git-filter-repo 确定泄露信息的格式，比如学号\u0026quot;2337xxxx\u0026quot;，则可以使用 git filter-repo --replace-text \u0026lt;(echo \u0026quot;2337xxxx==\u0026gt;\u0026quot;) 将所有历史提交中的\u0026quot;2337xxxx\u0026quot;替换为空串。如果要删除某个文件，可以使用 git filter-repo --path file --invert-paths 上述的方法也许不够灵活，下面再介绍一种方法： 如果能够确定是最近几次提交中泄露的信息，可以使用 git rebase -i HEAD~\u0026lt;x\u0026gt; 来修改最近 x 次提交。 终端会打开文本编辑器，显示这几次提交的 hash 信息和 commit 消息，将需要修改的提交前的 pick 改为 edit，然后保存退出。 此时工作区会恢复到第一条转为 edit 的提交被提交之前的状态，可以在此时清除信息。 使用 git commit --amend 修改提交消息。 使用 git rebase --continue 继续修改下一条提交。 -这些操作之后，由于你修改了历史提交记录，推送到远程仓库时必须使用 git push --force 来强制覆盖远程仓库的记录。注意 OS 和 OO 的 gitlab 是不支持强制推送的，只有在你自己的 Github 仓库中你才有权利这么做，而如果有别的协作者，他们需要使用 git fetch 和 git reset --hard origin/main 来避免与远程仓库的冲突。 Thinking 0.4 Git 的使用 2 # 操作流程 # cd ~/learnGit #1 touch README.txt echo \u0026#34;Testing 1\u0026#34; \u0026gt; README.txt git add . git commit -m \u0026#34;1\u0026#34; # repeat with commit message \u0026#34;2\u0026#34; and \u0026#34;3\u0026#34; git log #2 git reset --hard HEAD^ git log #3 git reset --hard \u0026lt;HASHCODE_1\u0026gt; # hashcode of commit with message \u0026#34;1\u0026#34; git log #4 git reset --hard \u0026lt;HASHCODE_3\u0026gt; # hashcode of commit with message \u0026#34;3\u0026#34; 分析 # 使用 git reset --hard 命令可以进行版本回退或者切换到任何一个版本。\n使用 HEAD^ 切换到上一个版本 使用 HEAD~\u0026lt;x\u0026gt; 切换到前第 x 个版本 使用 hash 值切换到任意版本 这里可以看到，我们在 #2 中回退到上一个版本，此时执行 git log 会找不到提交消息为\u0026quot;3\u0026quot;的提交记录。如果不是事先记录下它的 hash 值，我们可能无法找到这条记录了。\n事实上并非找不到。可以使用 git reflog 来查看 HEAD 指针移动的历史记录。刚才我们 commit 了三次，随后 reset 一次，这四次指针移动的情况被 git reflog 完整的记录下来，我们就可以通过前三次记录找到提交消息为\u0026quot;3\u0026quot;的提交的哈希值。\nThinking 0.5 echo 的使用 # 操作流程 # echo first # first echo second \u0026gt; output.txt # output.txt: second echo third \u0026gt; output.txt # output.txt: third echo forth \u0026gt;\u0026gt; output.txt # output.txt: # third # forth 分析 # \u0026gt; 用于将命令的输出覆盖到文件中，\u0026gt;\u0026gt; 用于将命令的输出追加到文件中。\nThinking 0.6 文件的操作 # 操作流程 # # command #!/bin/bash touch test echo \u0026#39;#!/bin/bash\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test bash command \u0026gt; test bash test \u0026gt; result 分析 # 单引号用来引用完全的“字面值”的字符串。所有在单引号中的内容都会被原样保留，不会进行替换或者转义。 双引号用来引用字符串，但允许变量和命令的替换或转义。 反引号用于命令替换，即先执行反引号包含的命令，再将该命令的输出替换到当前位置。等价于$()。 ","date":"11 March 2025","externalUrl":null,"permalink":"/posts/oslab0/","section":"归档","summary":"","title":"OS Lab0 实验报告","type":"posts"},{"content":"打算尝试使用一下 NixOS，来做声明式配置系统的尝试。\n","date":"12 February 2025","externalUrl":null,"permalink":"/moments/2025_02_12_21_55/","section":"动态","summary":"","title":"2025_02_12_21_55","type":"moments"},{"content":"专注！Attention is alllll IIIII neeeeed.\n","date":"9 February 2025","externalUrl":null,"permalink":"/moments/2025_02_09_14_14/","section":"动态","summary":"","title":"2025_02_09_14_14","type":"moments"},{"content":"我决定放弃学习 SpinalHDL。\n为什么坚持了大半个寒假，最终我要选择在还有 8 天时间返校的时候放弃学习它呢？我的理由如下。\nSpinalHDL 的文档太少了。它只有官方给出的一份文档，对于语言当中的很多特性，我只能从中做粗浅的了解，而不能详细的掌握运用。 我的时间不够。我原本的目标是在寒假快速掌握 SpinaHDL，并搭建一个 CPU。但到如今，我在学习这门语言的过程中处处受阻。也许学习它的一些项目库的代码是我应该做的，但留给我的时间已经不多了。 我前几天尝试过训练一个 SpinalHDL 方面的专家 AI，但没有成功，并且浪费了很多时间。 sbt sucks. SpinalHDL(Scala) 所使用的编译工具 sbt 不是很好用。在 VSCode 上，你每次点击 run 生成的 Verilog 代码并不是最新的，和编辑器里的代码总有一点小小的时差。这也许是 sbt 和 VSCode 的配合（比如插件 Metals 的问题）并不是很好，或者是 sbt 编译速度太慢导致的。总之不是特别聪明。 我今天看到 HN 上对 SpinalHDL 一类语言的讨论，有个人的观点说服了我。原文是对 Chisel 的讨论，但两者差不多。他说：“硬件开发的真正成本在于硬币的另一面，即硬件验证。”虽然我可以通过 SpinalHDL、Chisel 之类的语言大大节省我的硬件设计的时间，但在验证方面，我不能完全保证它生成的 Verilog 代码一定是符合程序员逻辑的。为此我在验证阶段需要花费的时间比 Verilog 语言更多。这一点原因是今天促使我放弃学习 SpinalHDL 的最大原因。 在这个寒假的剩余时间里，我决定直接使用 Verilog 开始编写 CPU，努力把进度赶上。之后，我打算学习 System Verilog。Vivado 支持 System Verilog，为了更新更好的硬件描述语言特性，我就没有必要再用旧的 Verilog 了。寒假编写的 CPU 也会慢慢用 SV 改进。\n","date":"8 February 2025","externalUrl":null,"permalink":"/moments/2025_02_08_21_09/","section":"动态","summary":"","title":"2025_02_08_21_09","type":"moments"},{"content":" 第一条动态！\n","date":"19 January 2025","externalUrl":null,"permalink":"/moments/2025_01_19_23_29/","section":"动态","summary":"","title":"2025_01_19_23_29","type":"moments"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/buaa/","section":"标签","summary":"","title":"BUAA","type":"tags"},{"content":" 可能是，可能不是，全面准备吧。\n这是我 24 秋学习计组课程的心得总结，希望对你有所帮助。我主要从计分规则、资源获取、学习过程三个方面描述。\n1. 计分规则 # 计组分为理论、实验两个部分。我们这一届，理论成绩占比 60%，实验成绩占比 40%。实验部分就是令人闻风丧胆的计组上机，理论部分包括期末考试和平时作业两部分，不同老师给分不同。\n计组的老师都非常棒，因此在选课时没有需要避雷的。\n学习过程中，为了效益最大化：\n平时可以听 gxp 老师的课，他差不多会按照上机进度去讲对应的实验部分，而其他老师不会。这点很重要，特别是在 p5 流水线设计部分，有他的引导，学起来会轻松很多。 期末复习建议听 xlm 老师的课，前几节课他的研究生会作为助教来讲复习题，最后一节课 xlm 老师会来讲透题级别的总复习，明确告诉你考什么，重点复习什么，字字千金。 至于实验（上机）部分，需要注意：\npre、p0~p2 打好基础，尽量完成课上课下内容，通过即满分。 p3~p7 课上尽力过题，成绩是按照课上过题数量给分，而不是按照挂的次数扣分的。 课上估计有三次 gap（不通过）的机会。 2. 资源获取 # 学习过程中需要靠自己去寻找资源来辅助完成实验部分。\n最主要参考就是往届学长学姐的代码和说明文档，但请注意不要构成抄袭。\n健康计组忠告第一条： 抵制抄袭代码，拒绝剽窃行为。 2.1 GitHub # GitHub 上有许多往届同学的课设代码，简单搜索 BUAA CO 即可找到一大批。\n完成课程后，也欢迎把自己的代码上传到代码仓库，造福以后的学弟学妹们。但请注意要删除自己的个人信息！！！\n使用 git 在最终 commit 之前一定要检查一遍自己提交的版本有没有泄露个人信息，包括但不限于你的账号密码。 tangsongxiaoba/awesome-buaa-co 是我创建的一个 Awesome 项目，收录了 BUAA CO 的学习资源，包括往届代码、博客教程等，欢迎贡献！\n2.2 往届博客 # 在写代码的时候一般是这样一个流程：\nflowchart LR; subgraph Coding direction LR A[阅读要求] --\u003e B[构思架构] B --\u003e C[参考博客] C --\u003e|还有疑惑| D[参考代码] D --\u003e|验证设计| B D --\u003e E[完成编写] end 往届博客是重要资源，是学长学姐对设计文档的进一步解释与完善。其中的解惑与提示往往可以给你带来很大的启发。\n同时，往届博客还包含同学对上机的经验总结，每周一晚上上机之前看看往届博客对上机题的描述，会觉得有准备很多。\n但同时请注意：不同时期的课程组的要求是不一样的，因此往届博客不一定正确，需要仔细对照计组网站给出的教程予以辨别。比如：\n在我们这一届，一开始要求实现的指令集中包含有符号加法的 add，但是一开始要求其表现与无符号加法的 addu 一样。而往届要求实现的指令集包含的却是 addu，两者在 MIPS-C 中的操作码是完全不一样的。 我们的 p7 与往届相比，增加的外设是不一样的，因此也不能完全采用往届同学的代码。 尽信书，不如无书。 我在学习过程中，主要参考的往届博客有两个：\nFlyingLandlord\u0026rsquo;s Blog：神中神，p7 博客写的比课程组的教程好多了（ roife 的魔法科见闻：讲的也非常清晰到位。 这两个博客同时都总结了大量上机题，非常珍贵。\n我们这一届也涌现出了许多精彩博客，在此先推荐两个我知悉的：\nTrash Bin for Chi：室友的博客，同时包含了他写的数据生成相关的经历。他写的数据生成器\u0026amp;对拍器非常强大，是我们寝室的保命依仗（ Lazyfish \u0026amp; chilly_river：首通全满分的大佬博客，每周写完计组甚至还能在周末抽空飞去各地打 ACM。他的 p7 是我写 p7 时的主要参考，虽然感觉写的不够清晰，但都是极为正确的（在我们这一届）。 2.3 其他资源 # 23 级讨论区精华帖整理（正在进行中） 学院云盘链接：指名为“计算机学院 - 学业支持手册”的北航云盘链接，关注水群信息；其中包含专业各年级课程资料以及其他珍贵资料，非常宝贵。 HDLBits：练习 Verilog 的好网站，可以在这里提高 Verilog 的熟练度。 3. 学习过程 # 不要把计组课下拖到周末再完成，不然你会非常痛苦！！！ 这些过程也可以多多参考往届博客以及 23 级讨论区精华帖整理。\n3.1 pre、p0~p2 部分 # 主要学习 Logisim、Xilinx ISE、MARS 等工具的基本使用，Verilog、MIPS-ASM 的基本语法，有限状态机、硬件描述语言的基本思想。课程组网站的教程非常丰富，照着完成即可。其中我觉得重点要注意的有：\n保持对 Verilog 语言的熟悉，因为 p4~p7 主要是编写 Verilog 代码。Verilog 与一般概念的编程语言不同在于执行方式：\nVerilog 描述并行执行的硬件电路，其信号和模块是并行运作的； 一般编程语言是顺序执行的。 也就是说，Verilog 的一些语句的先后顺序并不是它们的执行顺序：它们是并行执行的。 比如：\nalways @ (posedge clk) begin count \u0026lt;= count + 1; ans \u0026lt;= count; end 这 begin-end 语句块中的两句是同时执行的，也就是说 ans 被更新为 count 的原有值而不是自增后的值。\n区分 Moore 型状态机和 Mealy 型状态机：\nMoore 型状态机的输出变化滞后于状态变化，因为其输出只和状态有关。 Mealy 型状态机的输出可以立即响应输入变化，因为其输出与状态和输入都有关系。 这本质上就是第一点提到的并行性（时序性）。有限状态机的输出是由组合逻辑决定的，因此是实时变化的；而状态是由时序逻辑决定的，所以是按时钟周期逐步更新的。\n对于 Moore 型状态机来说，当在本周期状态即将发生变化时，状态的实际更新会在下一个时钟周期完成。输出逻辑在下一个时钟周期才会检测到状态的变化，并根据组合逻辑更新输出值。\n对于 Mealy 型状态机来说，即使在本周期状态还未完成更新，输出也可以在本周期根据输入的变化立即改变。而状态的更新依然会在下一个时钟周期完成。\n其他部分乏善可陈，基本工具多用用，MIPS、Verilog 代码多写写就熟练了。\n3.2 p3~p7 部分 # p3 是 Logisim 单周期 CPU 的搭建。\n万事开头难，p3 也许是前期比较麻烦的一次任务，需要用图形化的 Logisim 把 CPU 搭建起来。建议善用 Tunnel 部件。\n在开始搭 CPU 之前建议先把数据通路画一遍，理清思路。整个 CPU 的数据通路大致如下：\nflowchart LR; subgraph CPU direction LR; PC --\u003e|pc| IM; PC --\u003e|pc| NPC; IM --\u003e|rs| RF; IM --\u003e|rt| RF; IM --\u003e|rt| mux1; IM --\u003e|rd| mux1; IM --\u003e|imm16| EXT; IM --\u003e|shamt| ALU; IM --\u003e|j26| NPC; mux1 --\u003e RF; RF --\u003e|RD1| ALU; RF --\u003e|RD2| mux2; RF --\u003e|RD2| DM; EXT --\u003e|extImm| mux2; mux2 --\u003e ALU; EXT --\u003e|extImm| NPC; NPC --\u003e|NPC| PC; NPC --\u003e|pc+4| mux3; ALU --\u003e|res| DM; ALU --\u003e|res| mux3; DM --\u003e|RD| mux3; mux3 --\u003e|WD| RF; end 以上并未包含控制器单元到各元件的连线。Mermaid 流程图没法确定位置，看上去不够直观，建议在过程中使用 draw.io 绘制 CPU 数据通路图。\nLogisim 的使用过程本身也就是一个画图的过程，所以其实也可以不绘制这个草稿。不过最终在 Logisim 顶层模块中的 CPU 数据通路应该和以上草稿的层次是一样的。也就是说，各个模块的内部连线应在子模块中完成，不要放到顶层模块中，以免增加模块复杂度导致调试难度的提升。\n在 p3 可以借鉴一部分往届的代码，但不同人的 Logisim 设计很难一样，所以借鉴意义并不是很大；此外不同时期课程要求不同，也会导致与往届同学的 Logisim CPU 对拍失效，所以谨慎参考。\np4 是 Verilog 单周期 CPU 的搭建。\n有了 p3 的基础，p4 只是将图形转化为代码，本质上没有区别。只是要多注意 Verilog 端口接线正确。Verilog 代码复杂冗长，建议配置好编程环境以进行代码检查与风格规范，在编写过程中也要时刻保持清醒，注意接线正确。\n从 p4 开始，往届同学的代码就比较有借鉴价值了，阅读往届代码往往可以加快课下任务的完成。但请确保你一定完全理解了代码及其原理（否则课上就难了），以及再次强调：不要抄袭！\np5 是 Verilog 流水线 CPU 的搭建。\n个人感觉 p5 是压力最大的一次任务，流水线概念理解非常困难，但是搭建时间同样只有一周，往往到课上还不能保证课下设计完全正确，而课上还很难。按顺序要做的有三件事情：\n增加五级流水线寄存器。 增加转发、暂停数据通路。 增加暂停逻辑。 增加转发逻辑。 这里比较难的就是数据通路和暂停转发逻辑。数据通路的问题是：究竟哪些部件要向前转发到哪些部件？ 暂停转发逻辑的问题则是对 AT 法的正确认识。这里个人感觉最麻烦的还是数据通路。建议听 gxp 老师的课以加强理解。\np6 是在 p5 的基础上增加乘除槽、更多指令以及改造 DM。难度也不大，照着教程走就行。\np7 是在 p6 的基础上进一步完善整个 MIPS 微系统，四舍五入就是一个 SoC。 p7 是继 p5 之后更艰巨的一次任务，概念理解更加困难，代码量也更大。而且，其中对于外设的要求每年都有所变化，往届代码的参考价值降低了（但大部分还是可以参考的）。p7 任务主要分为两部分：\n支持异常与中断 添加 Bridge 与外设，形成 MIPS 微系统 最终形成的 Verilog 代码结构如下。\nblock-beta block columns 1 block columns 3 IM int[[\"Interrupt\"]] DM end space:2 block columns 3 Peripherals space Bridge end space block columns 3 Pipeline space CP0 end end IM -- \"instr\" --\u003e Pipeline Pipeline --\u003e IM DM -- \"mem\" --\u003e Bridge Bridge --\u003e DM Bridge --\u003e Peripherals Peripherals --\u003e Bridge Bridge -- \"mem\" --\u003e Pipeline Pipeline --\u003e Bridge Bridge -- \"signal\" --\u003e CP0 int -- \"signal\" --\u003e CP0 Pipeline -- \"Exception\" --\u003e CP0 CP0 --\u003e Pipeline ","date":"15 January 2025","externalUrl":null,"permalink":"/posts/co23summary/","section":"归档","summary":"","title":"BUAA CO 学习心得","type":"posts"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0/","section":"标签","summary":"","title":"学习","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/categories/%E5%BF%83%E5%BE%97/","section":"分类","summary":"","title":"心得","type":"categories"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/","section":"标签","summary":"","title":"计算机组成","type":"tags"},{"content":" 最好的计划就是没有计划……\n写在前面 # 不知道第几次建站了，从小学五六年级开始想着要有自己的个人网站，反复折腾，弄好又弃坑……搭建在 Github 上也有好几个版本了。反正重开一次总是要写这些话，希望它能一直开张下去之类的美好祝愿吧（\n暑假刚好只剩下一个月了……前几周忙着社会实践和志愿活动，但这周回到家后好像也无所事事。遂写一份计划，列一下剩下的一个月里要做的事情吧。\n（24 年 11 月 27 日更新）转眼大二上学期也要过去了，这期间我也没有养成写博客的习惯，但确实想到了很多可以记录的事情。但回过头来看这篇文章，暑假计划也变成暑假总结了，而实际上两个月的暑假几乎什么也没有做成……\n暑假计划 # 程设通关指北 # 描述：暑假里打算给下一届的新同学们出一份《程序设计基础》课程的帮助。 缘由：从我们这一届来看，差距真的很大。学了一年，既有码风良好、效率优秀的，也有面向 CSDN 编程的。不多说了，希望能帮到大家吧。 成果：完成的时候这里会放 程设通关指北 (WIP) 的链接。 折腾 NixOS # 描述：系统已经安装好了，暑假里的目标是把系统配置好。 缘由：这是个 OS as Code 的系统，能通过配置文件一键设置好整个系统，想想就觉得很爽，所以一定要折腾一下。 成果：配置文件会上传到 Github，完成的时候这里会放 repo 的链接。 准备数模竞赛 # 描述：准备九/十月份的数学建模比赛，包括学习使用 Matlab 等等（其实我也不知道要学什么）。 缘由：年初过生日的时候被同学拉来要打数模，现在还有一个多月，感觉要寄。 成果：完成的时候放点笔记的链接。 预习大二课程 # 描述：花点时间学学 CO、概统、物理等课。 缘由：害怕回去被卷死。 成果：完成的时候放点笔记的链接。 监督妹妹学习 # 描述：妹妹过完暑假九年级了，暑假还是教教她吧，免得高中也考不上。 缘由：如上。 成果：完成的时候放张她打卡的表格。 折腾个人网站 # 描述：把个人网站上线且配置好。 缘由：因为要出《程设通关指北》啊。 成果：能有这篇文章，说明完成一半了。 其他安排 # 学点吉他 # 等 castle 回来去找他学学吉他。但其实想学 bass。\n写个 SSG # 这几天网站博客配置的头疼，想自己写一个 SSG，最好能够专注于写 Markdown 而只需要极少的配置的，不知道能不能实现。\n学学粤语 # 广东人怎么能不会粤语呢……寒假回访 UM 之前学会讲。\n结尾 # 一口气写完计划看上去还挺充足的，非常符合我天马行空而又不切实际的特质。不知道最后能完成几项啊。“暑假计划”部分截至正式开学的时间。加油吧。\n回顾 # 程设通关指北最后搁置了，创业未半而骈死于槽枥之间。不过后来通过了助教选拔考试，当上了航 C 助教，和这个计划反倒没有什么关系了。 NixOS 最后也删除了，没有继续研究下去。OS as Code 的理念确实好，但是总感觉用不上，导致自己动力不足。事实上，现在的 Windows 10 也准备重装了，也许今后会再次尝试。 数模竞赛在暑假是什么也没有准备，最后上场三天通宵两天把代码搓出来，拿了一个省二，算是意外的收获吧。 大二课程是一点也没有看。CO Pre 教程在暑假返校后做了一点，但开学后又犯了拖延症，一直到 Pre 上机（到现在也）还没完成。 监督妹妹学了两个星期，之后也不了了之。 个人网站在开学后搁置到了现在，为了阿里云备案而重新拾起…… 吉他没学，SSG 没写，粤语也不会。 总的来说就是一事无成，也许有些栏目可以给个半对表示完成了一半，但……没有意义。我马上要存在 20 年了，但对于我自己的认识还颇少，总是不相信自己的无能与怯懦，心里想着宏大的计划，但实际上却像这篇文章一样一事无成。\n","date":"20 July 2024","externalUrl":null,"permalink":"/posts/plan24su/","section":"归档","summary":"","title":"2024 年暑假总结","type":"posts"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/%E5%81%87%E6%9C%9F/","section":"标签","summary":"","title":"假期","type":"tags"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/%E7%94%9F%E6%B4%BB/","section":"标签","summary":"","title":"生活","type":"tags"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/categories/%E9%9A%8F%E7%AC%94/","section":"分类","summary":"","title":"随笔","type":"categories"},{"content":"","externalUrl":"https://blog.cast1e.top/","permalink":"","section":"友链","summary":"","title":"cast1e","type":"friends"},{"content":"","externalUrl":"https://kie-chi.github.io/","permalink":"","section":"友链","summary":"","title":"Chi","type":"friends"},{"content":"","externalUrl":"https://wtxyz.cn/","permalink":"","section":"友链","summary":"","title":"OWPETER","type":"friends"},{"content":" 人生的篇章，在此轻启心扉。 我是北京航空航天大学计算机学院二年级学生。\n","externalUrl":null,"permalink":"/about/","section":"欢迎！","summary":"","title":"你好！","type":"page"},{"content":" 知识的脉络，在此交织成章。\n","externalUrl":null,"permalink":"/categories/","section":"分类","summary":"","title":"分类","type":"categories"},{"content":" 流动的时光，在此留下足迹。\n","externalUrl":null,"permalink":"/moments/","section":"动态","summary":"","title":"动态","type":"moments"},{"content":" 缘分的桥梁，在此连接你我。\n","externalUrl":null,"permalink":"/friends/","section":"友链","summary":"","title":"友链","type":"friends"},{"content":" 时光的碎片，在此安放。\n","externalUrl":null,"permalink":"/posts/","section":"归档","summary":"","title":"归档","type":"posts"},{"content":" 思绪的标签，在此汇聚成海。\n","externalUrl":null,"permalink":"/tags/","section":"标签","summary":"","title":"标签","type":"tags"},{"content":" 万象的缩影，在此徐徐展开。\n这里是 tsxb 的个人博客，我会在这里分享一些自己的生活见闻，技术感悟。\n你可以访问以下页面来获取这个博客包含的更多信息：\n📚 归档：这里按日期排列了我所有的文章。 🗂️ 分类：这里按分类列出了我所有的文章。 🏷️ 标签：这里按标签列出了我所有的文章。 📖 关于：这里是我的个人介绍页面。 🤝 友链：这里是我的朋友们的博客链接。 🌟 动态：这里是我的动态。 ","externalUrl":null,"permalink":"/","section":"欢迎！","summary":"","title":"欢迎！","type":"page"}]